package v1exportservice

import (
	"fmt"
	"strings"

	"github.com/rogerwesterbo/godns/internal/models"
)

// FormatBINDZone formats a DNS zone in standard BIND zone file format
// This format is widely compatible with BIND, PowerDNS, and many other DNS servers
func FormatBINDZone(zone *models.DNSZone) string {
	var sb strings.Builder

	// Zone file header
	sb.WriteString(fmt.Sprintf("; Zone file for %s\n", zone.Domain))
	sb.WriteString("; Generated by GoDNS\n")
	sb.WriteString(";\n")
	sb.WriteString(fmt.Sprintf("$ORIGIN %s\n", zone.Domain))
	sb.WriteString("$TTL 300\n\n")

	// Add SOA record if exists, otherwise create a default one
	hasSOA := false
	for _, record := range zone.Records {
		if record.Type == "SOA" {
			sb.WriteString(formatBINDRecord(zone.Domain, &record))
			hasSOA = true
			break
		}
	}

	if !hasSOA {
		// Default SOA record
		sb.WriteString(fmt.Sprintf("@\t300\tIN\tSOA\tns1.%s hostmaster.%s (\n", zone.Domain, zone.Domain))
		sb.WriteString("\t\t\t\t1          ; Serial\n")
		sb.WriteString("\t\t\t\t3600       ; Refresh\n")
		sb.WriteString("\t\t\t\t1800       ; Retry\n")
		sb.WriteString("\t\t\t\t604800     ; Expire\n")
		sb.WriteString("\t\t\t\t300 )      ; Negative Cache TTL\n")
	}
	sb.WriteString("\n")

	// Group records by type for better readability
	recordsByType := make(map[string][]models.DNSRecord)
	for _, record := range zone.Records {
		if record.Type == "SOA" {
			continue // Already handled
		}
		recordsByType[record.Type] = append(recordsByType[record.Type], record)
	}

	// Output records by type
	typeOrder := []string{"NS", "A", "AAAA", "CNAME", "MX", "TXT", "SRV", "PTR", "CAA"}
	for _, recordType := range typeOrder {
		if records, exists := recordsByType[recordType]; exists {
			sb.WriteString(fmt.Sprintf("; %s Records\n", recordType))
			for _, record := range records {
				sb.WriteString(formatBINDRecord(zone.Domain, &record))
			}
			sb.WriteString("\n")
			delete(recordsByType, recordType)
		}
	}

	// Output any remaining record types
	for recordType, records := range recordsByType {
		sb.WriteString(fmt.Sprintf("; %s Records\n", recordType))
		for _, record := range records {
			sb.WriteString(formatBINDRecord(zone.Domain, &record))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// formatBINDRecord formats a single DNS record in BIND format
func formatBINDRecord(zoneDomain string, record *models.DNSRecord) string {
	name := record.Name

	// Convert FQDN to relative name if within the zone
	if name == zoneDomain {
		name = "@"
	} else if strings.HasSuffix(name, "."+zoneDomain) {
		// Make it relative to the zone
		name = strings.TrimSuffix(name, "."+zoneDomain)
	}

	// Handle SOA records specially for better formatting
	if record.Type == "SOA" {
		parts := strings.Fields(record.Value)
		if len(parts) >= 7 {
			return fmt.Sprintf("@\t%d\tIN\tSOA\t%s %s (\n"+
				"\t\t\t\t%s          ; Serial\n"+
				"\t\t\t\t%s       ; Refresh\n"+
				"\t\t\t\t%s       ; Retry\n"+
				"\t\t\t\t%s     ; Expire\n"+
				"\t\t\t\t%s )      ; Negative Cache TTL\n",
				record.TTL, parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6])
		}
	}

	// Handle MX records with priority
	if record.Type == "MX" {
		return fmt.Sprintf("%s\t%d\tIN\t%s\t%s\n", name, record.TTL, record.Type, record.Value)
	}

	// Standard format for all other records
	return fmt.Sprintf("%s\t%d\tIN\t%s\t%s\n", name, record.TTL, record.Type, record.Value)
}
